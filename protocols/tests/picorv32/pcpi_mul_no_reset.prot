// This file is identical to `pcpi_mul.prot`, except for minor changes 
// (see comments below)

struct picorv32_pcpi_mul {
  in resetn: u1,
  in pcpi_insn: u32,
  in pcpi_rs1: u32,
  in pcpi_rs2: u32,
  out pcpi_wr: u1,
  out pcpi_ready: u1,
  in pcpi_valid: u1,
  out pcpi_rd: u32,
}

// Adapted from https://github.com/ekiwi/paso/blob/ad2bf83f420ca704ff0e76e7a583791a0e80a545/benchmarks/src/benchmarks/picorv32/PicoRV32Spec.scala#L27
prot pcpi_mul<p: picorv32_pcpi_mul>(
    in rs1_data: u32,
    in rs2_data: u32,
    out rd_data: u32,
  ) {
  // NOTE: the line `p.resetn := 1'b1` has been removed here  
  p.pcpi_valid := 1'b1;
  p.pcpi_insn := 32'b10000000000000000000110011; // multiplication insn


  p.pcpi_rs1 := rs1_data;
  p.pcpi_rs2 := rs2_data;
  
  assert_eq(p.pcpi_wr, 1'b0);
  assert_eq(p.pcpi_ready, 1'b0);

  while (!(p.pcpi_ready == 1'b1)) {
    step();
  }

  p.pcpi_valid := 1'b0;
  p.pcpi_insn := X;
  p.pcpi_rs1 := X;
  p.pcpi_rs2 := X;


  assert_eq(p.pcpi_wr, 1'b1);
  assert_eq(p.pcpi_rd, rd_data);

  // TODO: do we need/want this step?
  step();
}

prot pcpi_mul_reset_normal<p: picorv32_pcpi_mul>() {
  p.resetn := 1'b0;
  step();
  // keep the second cycle for consistency with pcpi_mul_reset_one
  fork();
  p.resetn := X;
  step();
}

prot pcpi_mul_reset_one<p: picorv32_pcpi_mul>() {
  p.resetn := 1'b0;
  step();
  fork();
  // set reset to 1
  // if the pcpi_mul transaction terminates, it signals that this assignment
  // is persistent past the termination of this thread.  
  p.resetn := 1'b1; 
  step();
}