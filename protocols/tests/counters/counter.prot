// corresponds with examples/counters/counter.v
// the Counter increments s up to a, and then sets s to 0 when s > a
struct Counter {
    in a: u64,
    out s: u64,
}

// Update (11/9): this protocol is considered to be ill-formed
// because the guard for the while-loop refer to an
// input port of the DUT, which is forbidden (see `well-formedness.md`)

prot count_up<dut: Counter>(in a: u64) {
    // Loading dut with values
    dut.a := a;

    while !(dut.s == dut.a) {
        step(1);
    }
    // now, dut.s == dut.a. Since s >= a, stepping once
    // more should result with dut.0 equal 0
    step(1);
    assert_eq(dut.s, 64'b0);
    
    fork();
    step();
}
