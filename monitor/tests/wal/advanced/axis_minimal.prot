// ARGS: --wave wal/advanced/uart-axi-minimal.fst --instances uut_rx:AXIS --sample-posedge uut_rx.clk --show-waveform-time --time-unit ns
//
// This implementation of an AXI-Streaming Protocol is a bit different from the WAL version.

struct AXIS {
    out m_axis_tready: u1,
    in m_axis_tvalid: u1,
    in m_axis_tdata: u8,
}

fn send_data<D: AXIS>(in data: u8) {
    D.m_axis_tdata := data;
    D.m_axis_tvalid := 1'b1;
    while (!(D.m_axis_tready == 1'b1)) {
        step();
    }
    // Enforce expected values for the ready & valid signals after the loop
    D.m_axis_tvalid := 1'b1;
    assert_eq(D.m_axis_tready, 1'b1);
    // one cycle for the data transfer to take place
    step();
    // TODO: can we get rid of this boiler plate code?
    D.m_axis_tdata := X;
    D.m_axis_tvalid := X;
    fork();
    step();
}

// We mark this protocol as `idle` to avoid excessive `idle()` transcations 
// showing up in the trace produced by the monitor
#[idle]
fn idle<D: AXIS>() {
    D.m_axis_tvalid := 1'b0;
    // D.data is implicitly Xi
    step();
    // TODO: can we get rid of this boiler plate code?
    D.m_axis_tdata := X;
    D.m_axis_tvalid := X;
    fork();
    step();
}