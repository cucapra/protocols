// ARGS: --wave wishbone/reqwalker.vcd --instances TOP.reqwalker:WBSubordinate --sample-posedge TOP.reqwalker.i_clk

// Wishbone B4 (Pipeline mode) subordinate


// TODO: run the monitor on some existing waveforms 
// Eventually put all the traces in a separate repo

// For Wishbone, you can model everything using the same interface,
// whereas for AXI we can't do this (because responses can be out of order in AXI <---- is this true?)

// See if there is already a thing which takes Wishbone inputs/outputs and outputs transaction trace 
// ^^ such a thing might already exist and is hard-coded 
// TODO: see https://github.com/wallento/cocotbext-wishbone for a possible monitor

struct WBSubordinate {
    // Cycle is high anytime an active pipeline session is occurring
    in i_cyc: u1, 

    // Strobe is high when there is a request to the subordinate
    // (akin to Valid in AXI-Lite, i.e. they indicate the manager 
    // has something to transfer)
    in i_stb: u1,

    // Write-enable (true for write-requests)
    in i_we: u1,

    // Address of the request
    in i_addr: u1,

    // Data to be written 
    in i_data: u32, 

    // Response from the subordinate, indicating that the request
    // has been fulfilled. 
    out o_ack: u1,

    // True on any cycle when the subordinate can't accept requests 
    // False when a request can be accepted
    // (i.e. the opposite of Ready in AXI-Lite)
    out o_stall: u1,

    // Data returned by the subordinate to the manager
    // This is valid only when ACK is true
    out o_data: u32,

    // LED output: one-hot encoding of the current walker state
    out o_led: u6
}

// Both cyc & stb are low when the subordinate is low,
// everything else is DontCare
#[idle]
prot idle<DUT: WBSubordinate>() {
    DUT.i_cyc  := 1'b0;
    DUT.i_stb  := 1'b0;
    DUT.i_we   := X;
    DUT.i_addr := X;
    DUT.i_data := X;
    step();
}

// Writes a `data` value to the subordinate, and observes the 
// resultant `led` state via an output parameter. 
// Wishbone says to hold all request signals while stalled (stall=1), 
// i.e. when the subordinate is busy processing a previous request.
prot write<DUT: WBSubordinate>(in addr: u1, in data: u32, out led: u6) {
    DUT.i_cyc  := 1'b1;
    DUT.i_stb  := 1'b1;
    DUT.i_we   := 1'b1;
    DUT.i_addr := addr;
    DUT.i_data := data;
    // For reqwalker, stall is combinatorial: o_stall = busy && i_we.
    // When state=0 (idle, can accept), busy=0 so stall=0 before the accept posedge.
    // Stall=1 only appears AT the accept posedge (state 0->1), so the loop
    // is omitted here; the monitor samples posedge values where stall=1 already
    // coincides with ack=1 (post-accept artifact).
    // Request accepted on this cycle; ack registered next cycle
    step();
    // i_stb goes to DontCare after acceptance: per Wishbone B4 the master may
    // keep stb high for pipelined requests, and in VCDs the 0 only appears at
    // the *next* posedge (testbench sets it after tick() returns).
    DUT.i_cyc  := X;
    DUT.i_stb  := X;
    DUT.i_we   := X;
    DUT.i_addr := X;
    DUT.i_data := X;

    // Based on the Verilog, there is a 1 cycle latency before the
    // ack is registered.
    while (DUT.o_ack == 1'b0) {
        step();
    }

    // Ack is now 1, the data write is complete
    // Note: During the ACK phase, we have i_cyc=1 (session still active)
    // and i_stb=0 (no new request).

    // Observe resultant LED state
    assert_eq(DUT.o_led, led);

    // Set to DontCare so the next protocol can decide whether to continue.
    // No explicit fork(): using implicit fork so the next transaction starts
    // at the *next* cycle (after i_cyc drops to 0 and the bus becomes idle).
    DUT.i_stb := X;
    DUT.i_cyc := X;
    step();
}

// Reads a value and the LED state from the subordinate
// (the `data` and the `led` state are conveyed via output parameters)
prot read<DUT: WBSubordinate>(in addr: u1, out data: u32, out led: u6) {
    DUT.i_cyc  := 1'b1;
    DUT.i_stb  := 1'b1;
    DUT.i_we   := 1'b0;
    DUT.i_addr := addr;
    DUT.i_data := X;

    // Wait while the subordinate stalls
    while (DUT.o_stall == 1'b1) {
        step();
    }
    // Read request accepted, one cycle for data transfer.
    // i_stb goes to DontCare after acceptance (same reasoning as write above).
    step();
    DUT.i_stb  := X;
    DUT.i_we   := X;
    DUT.i_addr := X;

    // Wait for ack; data is valid to read when ack becomes 1
    while (DUT.o_ack == 1'b0) {
        step();
    }

    // Observe resultant data value & LED state
    assert_eq(DUT.o_data, data);
    assert_eq(DUT.o_led, led);

    // Set to DontCare so the next protocol can decide whether to continue.
    // No explicit fork(): using implicit fork so the next transaction starts
    // at the *next* cycle (after i_cyc drops to 0 and the bus becomes idle).
    DUT.i_stb  := X;
    DUT.i_cyc := X;
    step();
}
