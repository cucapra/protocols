// ARGS: --wave wishbone/wishbone_0.fst --instances reqwalker:WBSubordinate 

// Wishbone B4 (Pipeline mode) subordinate
struct WBSubordinate {
    // Cycle is high anytime an active pipeline session is occurring
    in i_cyc: u1,

    // Strobe is high when there is a request to the subordinate
    // (akin to Valid in AXI-Lite, i.e. they indicate the manager
    // has something to transfer)
    in i_stb: u1,

    // Write-enable (true for write-requests)
    in i_we: u1,

    // Address of the request
    in i_addr: u1,

    // Data to be written
    in i_data: u32,

    // Response from the subordinate, indicating that the request
    // has been fulfilled.
    out o_ack: u1,

    // True on any cycle when the subordinate can't accept requests
    // False when a request can be accepted
    // (i.e. the opposite of Ready in AXI-Lite)
    out o_stall: u1,

    // Data returned by the subordinate to the manager
    // This is valid only when ACK is true
    out o_data: u32,

    // LED output: one-hot encoding of the current walker state
    out o_led: u6
}

// Both cyc & stb are low when the subordinate is low,
// everything else is DontCare
#[idle]
prot idle<DUT: WBSubordinate>() {
    DUT.i_cyc  := 1'b0;
    DUT.i_stb  := 1'b0;
    DUT.i_we   := X;
    DUT.i_addr := X;
    DUT.i_data := X;
    step();
}

// Writes a `data` value to the subordinate, and observes the
// resultant `led` state via an output parameter.
// Wishbone says to hold all request signals while stalled (stall=1),
// i.e. when the subordinate is busy processing a previous request.
prot write<DUT: WBSubordinate>(in addr: u1, in data: u32, out led: u6) {
    DUT.i_cyc  := 1'b1;
    DUT.i_stb  := 1'b1;
    DUT.i_we   := 1'b1;
    DUT.i_addr := addr;
    DUT.i_data := data;

    // Wait till the subordinate Acks
    // Note that in the Verilog, after the subordinate acks, 
    // `o_stall` is assigned combinationally (`o_stall = busy && i_we`), 
    // so we don't need another while-loop to wait for `stall` to become 0
    while (DUT.o_ack == 1'b0) {
        step();
    }

    // Data and led are updated combinationally in the same cycle as the ack,
    // so no separate cycle for data transfer is needed
    assert_eq(DUT.o_led, led);

    // Transaction has finished, so set `cyc` and `stb` to 0
    DUT.i_cyc := 1'b0;
    DUT.i_stb := 1'b0;

    // Set other inputs to DontCare
    DUT.i_we   := X;
    DUT.i_addr := X;
    DUT.i_data := X;
    
    step();
}

// Reads a value and the LED state from the subordinate
// (the `data` and the `led` state are conveyed via output parameters)
prot read<DUT: WBSubordinate>(in addr: u1, out data: u32, out led: u6) {
    DUT.i_cyc  := 1'b1;
    DUT.i_stb  := 1'b1;
    DUT.i_we   := 1'b0;
    DUT.i_addr := addr;
    DUT.i_data := X;

    // Wait for subordinate to Ack
    // (Same logic as `write` protocol, and same reason why we don't need
    // another while-loop for `stall` to become 0)
    while (DUT.o_ack == 1'b0) {
        step();
    }

    // Data and led are updated combinationally in the same cycle as the ack,
    // so no separate cycle for data transfer is needed
    assert_eq(DUT.o_data, data);
    assert_eq(DUT.o_led, led);

    // Transaction has finished, so set `cyc` and `stb` to 0
    DUT.i_cyc := 1'b0;
    DUT.i_stb := 1'b0;
    
    // Set other inputs to DontCare
    DUT.i_we   := X;
    DUT.i_addr := X;
    
    step();
}
