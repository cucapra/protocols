// ARGS: --wave bnw_fifo/axis_fifo_fixed.fst --instances TOP.test_axis_fifo:AxisFifo --sample-posedge TOP.test_axis_fifo.clk --show-waveform-time --time-unit ns

// AXI-Stream FIFO with frame-level atomicity (FIXED VERSION)
// Maps to axis_fifo.v module I/O ports
struct AxisFifo {
    // Control signals
    in rst: u1,                   // Active-high reset signal

    // AXI-Stream receiver Interface (FIFO input/write side)
    in s_axis_tdata: u8,          // receiver data bus (payload)
    in s_axis_tkeep: u1,          // receiver byte-lane keeper (valid bytes indicator)
    in s_axis_tvalid: u1,         // receiver valid signal (initiator has valid data)
    in s_axis_tlast: u1,          // receiver last signal (marks end of frame/packet)
    in s_axis_tid: u8,            // receiver transaction ID (for routing/ordering)
    in s_axis_tdest: u8,          // receiver destination ID (routing information)
    in s_axis_tuser: u1,          // receiver user-defined sideband (e.g., error flags)

    // AXI-Stream sender Interface (FIFO output/read side)
    in m_axis_tready: u1,         // sender ready signal (receiver can accept data)

    // Outputs
    out s_axis_tready: u1,        // receiver ready signal (FIFO can accept data)
    out m_axis_tdata: u8,         // sender data bus (payload)
    out m_axis_tkeep: u1,         // sender byte-lane keeper
    out m_axis_tvalid: u1,        // sender valid signal (FIFO has valid data)
    out m_axis_tlast: u1,         // sender last signal (end of frame)
    out m_axis_tid: u8,           // sender transaction ID
    out m_axis_tdest: u8,         // sender destination ID
    out m_axis_tuser: u1,         // sender user-defined sideband
}

// PUSH_AND_POP: Concurrent push and pop in the same cycle
// 
// Push Arguments (input):
// `push_data, push_keep, push_last, push_id, push_dest, push_user` - Data to write
// 
// Pop Arguments (output, verified with assert_eq):
// `pop_data, pop_keep, pop_last, pop_id, pop_dest, pop_user` - Expected data read
fn push_and_pop<DUT: AxisFifo>(
    // Push parameters
    in push_data: u8,
    in push_keep: u1,
    in push_last: u1,
    in push_id: u8,
    in push_dest: u8,
    in push_user: u1,
    // Pop parameters
    out pop_data: u8,
    out pop_keep: u1,
    out pop_last: u1,
    out pop_id: u8,
    out pop_dest: u8,
    out pop_user: u1
) {
    // Indicate that receiver is ready for the PUSH
    DUT.s_axis_tdata := push_data;
    DUT.s_axis_tkeep := push_keep;
    DUT.s_axis_tvalid := 1'b1;
    DUT.s_axis_tlast := push_last;
    DUT.s_axis_tid := push_id;
    DUT.s_axis_tdest := push_dest;
    DUT.s_axis_tuser := push_user;

    // Indicate that sender is ready for the POP
    DUT.m_axis_tready := 1'b1;

    // Wait till receiver's ready bit is 1 so that we can perform the PUSH
    while (!(DUT.s_axis_tready == 1'b1)) {
        step();
    }

    // Wait until sender's valid bit is 1 so that we can perform the POP 
    while (!(DUT.m_axis_tvalid == 1'b1)) {
        step();
    }

    // One cycle for both data transfers to complete
    step();

    // Verify pop outputs
    assert_eq(DUT.m_axis_tdata, pop_data);
    assert_eq(DUT.m_axis_tkeep, pop_keep);
    assert_eq(DUT.m_axis_tlast, pop_last);
    assert_eq(DUT.m_axis_tid, pop_id);
    assert_eq(DUT.m_axis_tdest, pop_dest);
    assert_eq(DUT.m_axis_tuser, pop_user);

    // Mark all inputs as DontCare
    DUT.s_axis_tdata := X;
    DUT.s_axis_tkeep := X;
    DUT.s_axis_tvalid := X;
    DUT.s_axis_tlast := X;
    DUT.s_axis_tid := X;
    DUT.s_axis_tdest := X;
    DUT.s_axis_tuser := X;
    DUT.m_axis_tready := X;

    fork();
    step();
}

// PUSH: Write data to FIFO via AXI-Stream receiver interface
// Performs data transfer when s_axis_tvalid and s_axis_tready are both 1
//
// Arguments:
//   data - Payload byte to write to FIFO
//   keep - Byte lane valid indicator (1 = byte is valid)
//   last - End-of-frame marker (1 = last beat of packet)
//   id   - Transaction ID for routing/ordering
//   dest - Destination ID for routing
//   user - User-defined sideband data (e.g., error/parity bits)
fn push<DUT: AxisFifo>(
    in data: u8,
    in keep: u1,
    in last: u1,
    in id: u8,
    in dest: u8,
    in user: u1
) {
    DUT.s_axis_tdata := data;
    DUT.s_axis_tkeep := keep;
    DUT.s_axis_tvalid := 1'b1;
    DUT.s_axis_tlast := last;
    DUT.s_axis_tid := id;
    DUT.s_axis_tdest := dest;
    DUT.s_axis_tuser := user;

    // Ensure pop control port is disabled (mutually exclusive with pop)
    DUT.m_axis_tready := 1'b0;

    // Wait for FIFO to be ready to accept data
    while (!(DUT.s_axis_tready == 1'b1)) {
        step();
    }

    // One cycle for the transfer to complete
    step();

    // Release inputs after transaction
    DUT.s_axis_tdata := X;
    DUT.s_axis_tkeep := X;
    DUT.s_axis_tvalid := X;
    DUT.s_axis_tlast := X;
    DUT.s_axis_tid := X;
    DUT.s_axis_tdest := X;
    DUT.s_axis_tuser := X;

    fork();
    step();
}

// POP: Read data from FIFO via AXI-Stream sender interface
// Data transfer occurs when `m_axis_tvalid` and `m_axis_tready` are both 1
//
// Output Arguments (verified with assert_eq):
//   data - Expected payload byte from FIFO
//   keep - Expected byte lane valid indicator
//   last - Expected end-of-frame marker
//   id   - Expected transaction ID
//   dest - Expected destination ID
//   user - Expected user-defined sideband data
fn pop<DUT: AxisFifo>(
    out data: u8,
    out keep: u1,
    out last: u1,
    out id: u8,
    out dest: u8,
    out user: u1
) {
    DUT.m_axis_tready := 1'b1;

    // Ensure push control port is disabled (mutually exclusive with push)
    DUT.s_axis_tvalid := 1'b0;

    // Wait for FIFO to have valid data available
    while (!(DUT.m_axis_tvalid == 1'b1)) {
        step();
    }

    // One cycle for the transfer to complete
    step();

    // Capture output data
    assert_eq(DUT.m_axis_tdata, data);
    assert_eq(DUT.m_axis_tkeep, keep);
    assert_eq(DUT.m_axis_tlast, last);
    assert_eq(DUT.m_axis_tid, id);
    assert_eq(DUT.m_axis_tdest, dest);
    assert_eq(DUT.m_axis_tuser, user);

    // Release inputs after transaction
    DUT.m_axis_tready := X;

    fork();
    step();
}

// IDLE: No transaction occurs
// Both valid signals are deasserted
fn idle<DUT: AxisFifo>() {
    DUT.s_axis_tvalid := 1'b0;
    DUT.m_axis_tready := 1'b0;
    step();

    // Release all inputs
    DUT.s_axis_tdata := X;
    DUT.s_axis_tkeep := X;
    DUT.s_axis_tvalid := X;
    DUT.s_axis_tlast := X;
    DUT.s_axis_tid := X;
    DUT.s_axis_tdest := X;
    DUT.s_axis_tuser := X;
    DUT.m_axis_tready := X;
    DUT.rst := X;

    fork();
    step();
}

// RESET: Assert reset signal to initialize FIFO
fn reset<DUT: AxisFifo>() {
    DUT.rst := 1'b1;
    DUT.s_axis_tvalid := 1'b0;
    DUT.m_axis_tready := 1'b0;
    step();

    // Release all inputs
    DUT.rst := X;
    DUT.s_axis_tdata := X;
    DUT.s_axis_tkeep := X;
    DUT.s_axis_tvalid := X;
    DUT.s_axis_tlast := X;
    DUT.s_axis_tid := X;
    DUT.s_axis_tdest := X;
    DUT.s_axis_tuser := X;
    DUT.m_axis_tready := X;

    fork();
    step();
}