// ARGS: --wave fifo/fifo.fst --instances fifo_wrapper:Fifo
struct Fifo {
    in data_i: u32,
    in v_i: u1,             // Indicates if the data is valid
    in enq_not_deq_i: u1,
    out full_o: u1,         // Indicates if the FIFO is full
    out empty_o: u1,        // Indicates if the FIFO is empty
    out data_o: u32 
}

fn push<DUT: Fifo>(in input: u32) {
    DUT.enq_not_deq_i := 1'b1;
    DUT.v_i := 1'b1;
    DUT.data_i := input;
    step();
    DUT.enq_not_deq_i := X;
    DUT.v_i := X;
    DUT.data_i := X; 
    fork();
    step();
}

// Note: the results of the `pop` are only visible after one cycle
// because the memory read happens at the clock transition
fn pop<DUT: Fifo>(out output: u32) {
    DUT.enq_not_deq_i := 1'b0;
    DUT.v_i := 1'b1;
    step();
    fork();
    // The output data is undefined if the FIFO is empty,
    // so we only check equality if the empty bit is not true
    if !(DUT.empty_o == 1'b1) {
        assert_eq(DUT.data_o, output); 
        step();
    } else {
        step();
    }
}

#[idle]
fn idle<DUT: Fifo>() {
    DUT.v_i := 1'b0;
    step();
    DUT.data_i := X;
    DUT.enq_not_deq_i := X;
    fork();
    step();
}