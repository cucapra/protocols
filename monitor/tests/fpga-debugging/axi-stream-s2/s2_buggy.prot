// ARGS: --wave fpga-debugging/axi-stream-s2/s2_buggy.fst --instances TOP.testbench.UUT.axi_stream_check:AXISManager --sample-posedge TOP.testbench.UUT.axi_stream_check.i_aclk --show-waveform-time --time-unit ns

// Source (manager) that outputs a sequence of 8 words
struct AXISManager {
    // Control signals
    in i_aresetn: u1,              // Active-low reset

    // AXI-Stream manager outputs (from DUT perspective)
    out i_tvalid: u1,              // manager has valid data
    out i_tdata: u32,              // Data payload
    out i_tstrb: u4,               // Byte strobe (always 0xF)
    out i_tlast: u1,               // Last word in packet

    // AXI-Stream sub-ordinate input 
    in i_tready: u1,               // Downstream ready to accept
}

// RESET: Assert reset (active-low) and wait for manager to be ready
// The manager waits C_M_START_COUNT cycles in INIT_COUNTER before sending
fn reset<DUT: AXISManager>() {
    DUT.i_aresetn := 1'b0;         // Assert reset (active-low)
    DUT.i_tready := 1'b0;
    step();

    // Release reset
    DUT.i_aresetn := 1'b1;
    step();
}

// RECV: Receive one data word from the AXI-Stream manager
// Data transfer occurs when i_tvalid and i_tready are both 1
// Only matches when data is immediately available (i_tvalid = 1)
//
// Output Arguments:
//   data - Expected payload from manager
fn recv<DUT: AXISManager>(
    out data: u32,
) {
    DUT.i_aresetn := 1'b1;         // Keep out of reset
    DUT.i_tready := 1'b1;          // Signal ready to receive

    // Only matches when data is available
    // (use wait_for_data for cycles when tready=1 but tvalid=0)
    assert_eq(DUT.i_tvalid, 1'b1);

    // Verify output data
    assert_eq(DUT.i_tdata, data);

    // One cycle for the transfer to complete
    step();
}

// RECV_LAST: Receive the last data word (with i_tlast asserted)
// This verifies both the data and that i_tlast is properly set
// Only matches when data is immediately available (i_tvalid = 1)
//
// Output Arguments:
//   data - Expected payload from manager (should be the last word)
fn recv_last<DUT: AXISManager>(
    out data: u32,
) {
    DUT.i_aresetn := 1'b1;         // Keep out of reset
    DUT.i_tready := 1'b1;          // Signal ready to receive

    // Only matches when data is available
    assert_eq(DUT.i_tvalid, 1'b1);

    // Verify output data and i_tlast
    assert_eq(DUT.i_tdata, data);
    assert_eq(DUT.i_tlast, 1'b1);

    // One cycle for the transfer to complete
    step();
}

// STALL: Assert backpressure (i_tready=0) while manager has valid data
// This tests that the manager properly holds its outputs stable during stall
// Only matches when i_tvalid=1 (data is available to stall)
fn stall<DUT: AXISManager>() {
    DUT.i_aresetn := 1'b1;         // Keep out of reset
    DUT.i_tready := 1'b0;          // Apply backpressure

    // Stall only applies when manager has valid data
    // If i_tvalid=0, this fails and we instead have an `idle` transaction
    assert_eq(DUT.i_tvalid, 1'b1);

    step();
}

// WAIT_FOR_DATA: Receiver is ready but no data is available
// Used when tready=1 but tvalid=0 (i.e. receiver is polling for data)
fn wait_for_data<DUT: AXISManager>() {
    DUT.i_aresetn := 1'b1;         // Keep out of reset
    DUT.i_tready := 1'b1;          

    // Only matches when no data is available
    assert_eq(DUT.i_tvalid, 1'b0);
    step();
}

// IDLE: No transaction - i_tready is deasserted
// Used when the receiver is not ready to accept data
#[idle]
fn idle<DUT: AXISManager>() {
    DUT.i_aresetn := 1'b1;         // Keep out of reset
    DUT.i_tready := 1'b0;          // Not ready
    step();
}
