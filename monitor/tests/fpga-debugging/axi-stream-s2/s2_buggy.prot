// ARGS: --wave fpga-debugging/axi-stream-s2/s2_buggy.fst --instances TOP.testbench.UUT.axi_stream_check:AXISManager --sample-posedge TOP.testbench.UUT.axi_stream_check.i_aclk --show-waveform-time --time-unit ns

// Source (manager) that outputs a sequence of 8 words
struct AXISManager {
    // Control signals
    in i_aresetn: u1,              // Active-low reset

    // AXI-Stream manager outputs (from DUT perspective)
    out i_tvalid: u1,              // manager has valid data
    out i_tdata: u32,              // Data payload
    out i_tstrb: u4,               // Byte strobe (always 0xF)
    out i_tlast: u1,               // Last word in packet

    // AXI-Stream sub-ordinate input 
    in i_tready: u1,               // Downstream ready to accept
}

fn recv<DUT: AXISManager>(
    out data: u32,
    out is_last: u1,
) {
    DUT.i_aresetn := 1'b1;         // Keep out of reset

    // we are free to signal ready or not, it does not matter until valid is asserted
    DUT.i_tready := X;


    // wait for valid data
    while(DUT.i_tvalid == 1'b0) {
        step();
    }

    // now we are allowed to stall for an arbitrary number of cycles as long
    // as we keep ready low
    DUT.i_tready := 1'b0;

    // non-deterministic decision on how long to apply backpressure for
    while(X) {
        // valid has to remain true even if we are stalling the transfer!
        assert_eq(DUT.i_tvalid, 1'b1);
        assert_eq(DUT.i_tdata, data);
        step();
    }
    // set ready to true for the final cycle
    DUT.i_tready := 1'b1;
    assert_eq(DUT.i_tvalid, 1'b1);
    assert_eq(DUT.i_tdata, data);

    // One cycle for the transfer to complete
    step();
}

// RESET: Assert reset (active-low) and wait for manager to be ready
// The manager waits C_M_START_COUNT cycles in INIT_COUNTER before sending
fn reset<DUT: AXISManager>() {
    DUT.i_aresetn := 1'b0;         // Assert reset (active-low)
    DUT.i_tready := 1'b0;
    step();
}

