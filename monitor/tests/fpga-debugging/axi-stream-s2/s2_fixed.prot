// ARGS: --wave fpga-debugging/axi-stream-s2/s2_fixed.fst --instances TOP.testbench.UUT.axi_stream_check:AXISManager --sample-posedge TOP.testbench.UUT.axi_stream_check.i_aclk --show-waveform-time --time-unit ns

// This is a source (manager) that outputs a sequence of 8 words (1-8)
struct AXISManager {
    // Control signals
    in i_aresetn: u1,              // Active-low reset

    // AXI-Stream manager outputs (from DUT perspective)
    out i_tvalid: u1,              // manager has valid data
    out i_tdata: u32,              // Data payload
    out i_tstrb: u4,               // Byte strobe (always 0xF)
    out i_tlast: u1,               // Last word in packet

    // AXI-Stream sub-ordinate input (we control this)
    in i_tready: u1,               // Downstream ready to accept
}

// RESET: Assert reset (active-low) and wait for manager to be ready
// The manager waits C_M_START_COUNT cycles in INIT_COUNTER before sending
fn reset<DUT: AXISManager>() {
    DUT.i_aresetn := 1'b0;         // Assert reset (active-low)
    DUT.i_tready := 1'b0;
    step();

    // Release reset
    DUT.i_aresetn := 1'b1;
    step();

    // Release inputs
    DUT.i_aresetn := X;
    DUT.i_tready := X;

    fork();
    step();
}

// RECV: Receive one data word from the AXI-Stream manager
// Data transfer occurs when i_tvalid and i_tready are both 1
//
// Output Arguments:
//   data - Expected payload from manager
fn recv<DUT: AXISManager>(
    out data: u32,
) {
    DUT.i_aresetn := 1'b1;         // Keep out of reset
    DUT.i_tready := 1'b1;          // Signal ready to receive

    // Wait for manager to have valid data
    while (!(DUT.i_tvalid == 1'b1)) {
        step();
    }

    // Verify output data
    assert_eq(DUT.i_tdata, data);

    // One cycle for the transfer to complete
    step();

    // Release inputs
    DUT.i_aresetn := X;
    DUT.i_tready := X;

    fork();
    step();
}

// RECV_LAST: Receive the last data word (with i_tlast asserted)
// This verifies both the data and that i_tlast is properly set
//
// Output Arguments:
//   data - Expected payload from manager (should be the last word)
fn recv_last<DUT: AXISManager>(
    out data: u32,
) {
    DUT.i_aresetn := 1'b1;         // Keep out of reset
    DUT.i_tready := 1'b1;          // Signal ready to receive

    // Wait for manager to have valid data
    while (!(DUT.i_tvalid == 1'b1)) {
        step();
    }

    // Verify output data and i_tlast
    assert_eq(DUT.i_tdata, data);
    assert_eq(DUT.i_tlast, 1'b1);

    // One cycle for the transfer to complete
    step();

    // Release inputs
    DUT.i_aresetn := X;
    DUT.i_tready := X;

    fork();
    step();
}

// STALL: Assert backpressure (i_tready=0) while manager has valid data
// This tests that the manager properly holds its outputs stable during stall
fn stall<DUT: AXISManager>() {
    DUT.i_aresetn := 1'b1;         // Keep out of reset
    DUT.i_tready := 1'b0;          // Apply backpressure

    // Wait for manager to have valid data
    // (so that we're actually stalling a data transfer)
    while (!(DUT.i_tvalid == 1'b1)) {
        step();
    }

    // Hold for one stall cycle
    step();

    // Release inputs
    DUT.i_aresetn := X;
    DUT.i_tready := X;

    fork();
    step();
}

// IDLE: No transaction - i_tready is deasserted
// Used when the receiver is not ready to accept data
#[idle]
fn idle<DUT: AXISManager>() {
    DUT.i_aresetn := 1'b1;         // Keep out of reset
    DUT.i_tready := 1'b0;          // Not ready
    step();

    // Release inputs
    DUT.i_aresetn := X;
    DUT.i_tready := X;

    fork();
    step();
}

