// ARGS: --wave fpga-debugging/axis-async-fifo-c4/c4_fixed.fst --instances TOP.test_axis_async_fifo.UUT.axis_reg_inst:Sender TOP.test_axis_async_fifo.UUT.axis_reg_inst:Receiver --sample-posedge TOP.test_axis_async_fifo.UUT.axis_reg_inst.clk --show-waveform-time --time-unit ns

// AXI-Stream asynchronous FIFO 
// Struct fields map to module I/O ports in `c4_fixed.v`

struct Sender {
    // Control signals
    in rst: u1,                   // Active-high reset signal

    // AXI-Stream receiver Interface (FIFO input/write side)
    in s_axis_tdata: u8,          // receiver data bus (payload)
    in s_axis_tkeep: u1,          // receiver byte-lane keeper (valid bytes indicator)
    in s_axis_tvalid: u1,         // receiver valid signal (initiator has valid data)
    in s_axis_tlast: u1,          // receiver last signal (marks end of frame/packet)
    in s_axis_tid: u8,            // receiver transaction ID (for routing/ordering)
    in s_axis_tdest: u8,          // receiver destination ID (routing information)
    in s_axis_tuser: u1,          // receiver user-defined sideband (e.g., error flags)
 
    // AXI-Stream sender Interface (FIFO output/read side)
    in m_axis_tready: u1,         // sender ready signal (receiver can accept data)

    // Output fields for the sender
    out m_axis_tdata: u8,         // sender data bus (payload)
    out m_axis_tkeep: u1,         // sender byte-lane keeper
    out m_axis_tvalid: u1,        // sender valid signal (FIFO has valid data)
    out m_axis_tlast: u1,         // sender last signal (end of frame)
    out m_axis_tid: u8,           // sender transaction ID
    out m_axis_tdest: u8,         // sender destination ID
    out m_axis_tuser: u1,         // sender user-defined sideband

    // Output fields for the receiver
    out s_axis_tready: u1,        // receiver ready signal (FIFO can accept data)  
}

// Only `Receiver` supports `pop`
struct Receiver {
    // Control signals
    in rst: u1,                   // Active-high reset signal

    // AXI-Stream receiver Interface (FIFO input/write side)
    in s_axis_tdata: u8,          // receiver data bus (payload)
    in s_axis_tkeep: u1,          // receiver byte-lane keeper (valid bytes indicator)
    in s_axis_tvalid: u1,         // receiver valid signal (initiator has valid data)
    in s_axis_tlast: u1,          // receiver last signal (marks end of frame/packet)
    in s_axis_tid: u8,            // receiver transaction ID (for routing/ordering)
    in s_axis_tdest: u8,          // receiver destination ID (routing information)
    in s_axis_tuser: u1,          // receiver user-defined sideband (e.g., error flags)
 
    // AXI-Stream sender Interface (FIFO output/read side)
    in m_axis_tready: u1,         // sender ready signal (receiver can accept data)

    // Output fields for the sender
    out m_axis_tdata: u8,         // sender data bus (payload)
    out m_axis_tkeep: u1,         // sender byte-lane keeper
    out m_axis_tvalid: u1,        // sender valid signal (FIFO has valid data)
    out m_axis_tlast: u1,         // sender last signal (end of frame)
    out m_axis_tid: u8,           // sender transaction ID
    out m_axis_tdest: u8,         // sender destination ID
    out m_axis_tuser: u1,         // sender user-defined sideband

    // Output fields for the receiver
    out s_axis_tready: u1,        // receiver ready signal (FIFO can accept data)  
}

// PUSH: Write data to FIFO via AXI-Stream receiver interface
// Performs data transfer when s_axis_tvalid and s_axis_tready are both 1
//
// Arguments:
//   data - Payload byte to write to FIFO

fn push<DUT: Sender>(
    in data: u8,
) {
    DUT.rst := 1'b0;

    // Update the data field and set receiver's valid bit to 1 to indicate 
    // that data transfer can occur
    DUT.s_axis_tdata := data;    
    DUT.s_axis_tvalid := 1'b1;

    // Wait for FIFO to be ready to accept data
    while (!(DUT.s_axis_tready == 1'b1)) {
        step();
    }

    // One cycle for the transfer to complete
    step();
}

// POP: Read data from FIFO via AXI-Stream sender interface
// Data transfer occurs when `m_axis_tvalid` and `m_axis_tready` are both 1
//
// Output Arguments:
//   data - Expected payload byte from FIFO
fn pop<DUT: Receiver>(
    out data: u8,
) {
    DUT.rst := 1'b0;
    DUT.m_axis_tready := 1'b1;

    // Wait for FIFO to have valid data available
    while (!(DUT.m_axis_tvalid == 1'b1)) {
        step();
    }

    // One cycle for the transfer to complete
    step();

    // Capture output data
    assert_eq(DUT.m_axis_tdata, data);

    // Release inputs after transaction (i.e. release all constraints)
    DUT.m_axis_tready := X;
    DUT.s_axis_tvalid := X;  
    DUT.rst := X;   

    fork();
    step();
}

// IDLE: No transaction occurs on the monitored interface
// For Sender: no push transaction (no data being written to FIFO)
// For Receiver: no pop transaction (no data being read from FIFO)

fn idle<DUT: Sender>() {
    DUT.rst := 1'b0;

    // Ensure no push handshake by setting valid = 0
    // (Push handshake requires s_axis_tvalid && s_axis_tready)
    DUT.s_axis_tvalid := 1'b0;

    // All other input signals are don't care when valid = 0
    DUT.s_axis_tdata := X;
    DUT.s_axis_tkeep := X;
    DUT.s_axis_tlast := X;
    DUT.s_axis_tid := X;
    DUT.s_axis_tdest := X;
    DUT.s_axis_tuser := X;
    DUT.m_axis_tready := X;

    step();
}

fn idle<DUT: Receiver>() {
    DUT.rst := 1'b0;

    // Ensure no pop handshake by setting ready = 0
    // (Pop handshake requires m_axis_tvalid && m_axis_tready)
    DUT.m_axis_tready := 1'b0;

    // All other input signals are don't care when ready = 0
    DUT.s_axis_tdata := X;
    DUT.s_axis_tkeep := X;
    DUT.s_axis_tvalid := X;
    DUT.s_axis_tlast := X;
    DUT.s_axis_tid := X;
    DUT.s_axis_tdest := X;
    DUT.s_axis_tuser := X;

    step();
}

// RESET: Assert reset signal to initialize FIFO
fn reset<DUT: Sender>() {
    DUT.rst := 1'b1;
    
    step();
}