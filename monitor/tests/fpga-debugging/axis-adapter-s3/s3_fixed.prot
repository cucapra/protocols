// ARGS: --wave fpga-debugging/axis-adapter-s3/s3_fixed.fst --instances TOP.test_axis_adapter_64_8.UUT:AXISManager --sample-posedge TOP.test_axis_adapter_64_8.UUT.clk --show-waveform-time --time-unit ns

// Source (manager) that outputs a sequence of 8 words
struct AXISManager {
    // Control signals
    in rst: u1,              // Active-low reset

    // AXI-Stream manager outputs (from DUT perspective)
    out input_axis_tvalid: u1,              // manager has valid data
    out input_axis_tdata: u32,              // Data payload
    out input_axis_tlast: u1,               // Last word in packet

    // AXI-Stream sub-ordinate input 
    in input_axis_tready: u1,               // Downstream ready to accept
}

// RESET: Assert reset (active-low) and wait for manager to be ready
// The manager waits C_M_START_COUNT cycles in INIT_COUNTER before sending
fn reset<DUT: AXISManager>() {
    DUT.rst := 1'b0;         // Assert reset (active-low)
    DUT.input_axis_tready := 1'b0;
    step();
}

// RECV: Receive one data word from the AXI-Stream manager
// Data transfer occurs when input_axis_tvalid and input_axis_tready are both 1
// Only matches when data is immediately available (input_axis_tvalid = 1)
//
// Output Arguments:
//   data - Expected payload from manager
fn recv<DUT: AXISManager>(
    out data: u32,
) {
    DUT.rst := 1'b1;         // Keep out of reset
    DUT.input_axis_tready := 1'b1;          // Signal ready to receive

    // Only matches when data is available
    // (use wait_for_data for cycles when tready=1 but tvalid=0)
    assert_eq(DUT.input_axis_tvalid, 1'b1);

    // Verify output data
    assert_eq(DUT.input_axis_tdata, data);

    // One cycle for the transfer to complete
    step();
}

// RECV_LAST: Receive the last data word (with input_axis_tlast asserted)
// This verifies both the data and that input_axis_tlast is properly set
// Only matches when data is immediately available (input_axis_tvalid = 1)
//
// Output Arguments:
//   data - Expected payload from manager (should be the last word)
fn recv_last<DUT: AXISManager>(
    out data: u32,
) {
    DUT.rst := 1'b1;         // Keep out of reset
    DUT.input_axis_tready := 1'b1;          // Signal ready to receive

    // Only matches when data is available
    assert_eq(DUT.input_axis_tvalid, 1'b1);

    // Verify output data and input_axis_tlast
    assert_eq(DUT.input_axis_tdata, data);
    assert_eq(DUT.input_axis_tlast, 1'b1);

    // One cycle for the transfer to complete
    step();
}

// STALL: Assert backpressure (input_axis_tready=0) while manager has valid data
// AXI-Stream requires output args (tdata, tlast) to remain stable during stall
// Only matches when the waveform contains input_axis_tvalid=1 (i.e. there is some valid data and it's available to stall)
fn stall<DUT: AXISManager>(out data: u32, out last: u1) {
    DUT.rst := 1'b1;         // Keep out of reset
    DUT.input_axis_tready := 1'b0;          // Apply backpressure

    // Stall only applies when manager has valid data
    // If input_axis_tvalid=0, this fails and we instead have an `idle` transaction
    assert_eq(DUT.input_axis_tvalid, 1'b1);

    // Capture output values before the stall cycle
    assert_eq(DUT.input_axis_tdata, data);
    assert_eq(DUT.input_axis_tlast, last);

    step();

    // Verify outputs remained stable during the stall
    assert_eq(DUT.input_axis_tdata, data);
    assert_eq(DUT.input_axis_tlast, last);
}

// WAIT_FOR_DATA: Receiver is ready but no data is available
// Used when tready=1 but tvalid=0 (i.e. receiver is polling for data)
fn wait_for_data<DUT: AXISManager>() {
    DUT.rst := 1'b1;         // Keep out of reset
    DUT.input_axis_tready := 1'b1;          

    // Only matches when no data is available
    assert_eq(DUT.input_axis_tvalid, 1'b0);
    step();
}

// IDLE: No transaction - input_axis_tready is deasserted
#[idle]
fn idle<DUT: AXISManager>() {
    DUT.rst := 1'b1;         // Keep out of reset
    DUT.input_axis_tready := 1'b0;          
    step();
}
